<!DOCTYPE HTML>
<TITLE>Tetris</TITLE>
<LINK REL="stylesheet" HREF="https://webdevkit.net/styles.css">

<!-- GLOBALS -->
<SCRIPT>
function query(selector) {
	let elements = document.querySelectorAll(selector)
	return elements.length > 1 ? elements : elements[0]
}
function listen(elements, types, listener, options) {
	if (types.indexOf(" ") > -1) types = types.split(" ")
	else types = [types]

	if (elements instanceof NodeList === false)
		elements = [elements]
	for (let type of types) 
		for (let element of elements)
			element.addEventListener(type, listener, options)
}
</SCRIPT>

<!-- MOUSE -->
<SCRIPT>
let Mouse = undefined
listen(document, "mousemove", (event) => {
	if (!Mouse) Mouse = {}
	let update = (event) => {
		Mouse.x = Math.round(event.clientX / window.innerWidth * 100) / 100,
		Mouse.y = Math.round(event.clientY / window.innerHeight * 100) / 100
	}
	update(event)
	listen(document, "click mousemove", update)
},	{ once: true })
</SCRIPT>

<!-- KEYBOARD -->
<SCRIPT>
let Keyboard = undefined
listen(document, "keydown", (event) => {
	if (!Keyboard) Keyboard = {}
	let animationFrameTimer
	let update = (event) => {
		if (event) {
			if (event.type === "keydown") Keyboard[event.code] = true
			else delete Keyboard[event.code]
		}

		if (Object.keys(Keyboard).length === 0)
			return cancelAnimationFrame(animationFrameTimer)
		animationFrameTimer = requestAnimationFrame(() => update())
	}
	update(event)
	listen(document, "keydown keyup", update)
	//listen(window, "blur", () => { console.log("blur"); if (animationFrameTimer) cancelAnimationFrame(animationFrameTimer) })
	//listen(window, "focus", () => { Keyboard = {} })
}, { once: true })
</SCRIPT>

<STYLE>
Q::before { content: "\201C" }
Q::after { content: "\201D" }

BODY { margin: 0 }

#Tetris { --x: 0.5; --y: 0.5;
font-family: "IBM Plex Serif", sans-serif; font-size: 2.4vh; line-height: 1.4;
max-width: 80ch; margin: 0 auto; padding: 0 2em 25vh; transition: opacity 1s }

#Tetris:not(.loaded) { opacity: 0 }
#Tetris.loaded { opacity: 1 }
#Tetris.visited { opacity: 1 !important }

#Tetris HEADER {
min-height: 100vh; transition: transform 1s ease-in-out;
display: grid; grid-template-columns: min-content; grid-template-rows: min-content; 
justify-content: center; align-content: center;
transform: translateY(-5vh) }
#Tetris HEADER H1, #Tetris HEADER H2 { margin: 0; display: inline-flex }
#Tetris HEADER H2 { margin-top: -100% }
#Tetris HEADER.focused { 
transition: transform 0.25s ease-in-out;
transform: translateY(-5vh) scale(1.1) }

#Tetris H3 { text-align: center; margin: 5em 0 2.5em; text-transform: uppercase }

/* CARDS */
#Tetris .card { --flipped: 0; --direction: 1; --maxX: 1; --maxY: 1;
                --offsetX: calc(var(--x) * 2 - 1); --offsetY: calc(var(--y) * 2 - 1);
will-change: box-shadow, transform;
backface-visibility: hidden;
border-radius: 4pt; overflow: hidden; display: inline-flex;
box-shadow: calc(var(--offsetX) * var(--maxX) * -1vmin + 0.5vmin)
            calc(var(--offsetY) * var(--maxY) * -1vmin + 0.5vmin)
            2vmin rgba(0,0,0,0.25);
transition: all 1s cubic-bezier(0.23, 1, 0.32, 1);
transform: perspective(100vmin)
           rotateX(calc(var(--offsetY) * var(--maxY) * -3deg))
           rotateY(calc(var(--offsetX) * var(--maxX) * 3deg + var(--direction) * var(--flipped) * 180deg)) }

#Tetris .card:hover { --maxX: 5; --maxY: 1.5 }
#Tetris .card.flipped { --flipped: 1 }

#Tetris .card.front IMG { opacity: 0 }
#Tetris .card.front { background: url("Artwork/Background.jpg"); background-size: contain; z-index: 1 }

#Tetris .card.back { --flipped: -1 }
#Tetris .card.back.flipped { --flipped: 0 }


/* LAYERS */
#Tetris .card.front::before,
#Tetris .card.front::after { --stack: 0; content: ""; display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
will-change: filter, transform;
filter: drop-shadow(calc(var(--offsetX) * -3px) calc(var(--offsetY) * -3px) 1px rgba(0,0,0,0.2));
transition: all 1s cubic-bezier(0.23, 1, 0.32, 1);
transform: perspective(100vmin)
           translateX(calc(var(--stack) * var(--offsetX) * var(--maxX) * 0.1vmin))
           translateY(calc(var(--stack) * var(--offsetY) * var(--maxY) * 0.1vmin)) }
#Tetris .card.front::before { --stack: 1;
background: url("Artwork/Logo Shadow.png") center no-repeat; background-size: 100% 100% }
#Tetris .card.front::after { --stack: 2;
background: url("Artwork/Logo Fill.png") center no-repeat; background-size: 100% 100% }
</STYLE>
<ARTICLE ID="Tetris">
<HEADER>
<H1><A CLASS="card front" HREF="Artwork.jpg"><IMG ALT="Tetris" SRC="Artwork.jpg" WIDTH="512" HEIGHT="512"/></A></H1>
<H2><A CLASS="card back" HREF="Description.jpg"><IMG ALT="From Russia with Fun!" SRC="Description.jpg" WIDTH="512" HEIGHT="512"/></A></H1>
</HEADER>
<SCRIPT>
let $tetris = query("#Tetris")
listen(window, "load", () => { setTimeout(() => query("#Tetris").classList.add("loaded"), 500) }) // simulate loading
listen(document, "mousemove", () => {
	if (!Mouse) return
	$tetris.style.setProperty("--x", Mouse.x)
	$tetris.style.setProperty("--y", Mouse.y)
})

setTimeout(() => { localStorage.setItem("tetris", true) }, 4500)
if (localStorage.getItem("tetris")) $tetris.classList.add("visited")


// CARDS
let timeout
for (let card of query("#Tetris .card"))
	listen(card, "mouseenter mouseleave", (event) => {
		if (timeout) clearTimeout(timeout)
		timeout = setTimeout(() => query("#Tetris HEADER").classList.toggle("focused", event.type === "mouseenter"), event.type === "mouseenter" ? 0 : 1000)
	})

listen(query("#Tetris HEADER A"), "click", (event) => {
	let normalize = (value, range) => (value * 2 - range) / range
	let normalizedLayerX = normalize(event.layerX, event.target.offsetWidth)
	if (Math.abs(normalizedLayerX) < 0.5) return

	event.preventDefault()
	for (let card of query("#Tetris .card")) {
		card.classList.toggle("flipped")	
		// card.classList.toggle("forwards", normalizedLayerX > 0.5)
		// card.classList.toggle("reversed", normalizedLayerX < 0.5)
	}
})
</SCRIPT>

<!-- <iframe style="float: right; margin-top: 0.5em; margin-left: 1em; border-radius: 4pt; width: 16em; height: 12em" width="256" height="192" src="https://www.youtube.com/embed/E-ej_8XBwmI?modestbranding=1&showinfo=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> -->
<P>Ahhh&hellip; <CITE>Tetris</CITE>. <Q CITE="https://www.mobygames.com/game/gameboy/tetris_gb/cover-art/gameCoverId,39235/">The relentless building block video puzzle</Q> game that launched with Nintendo&rsquo;s Game&nbsp;Boy in 1989.</P>
<P>The title comes from <EM>tetromino</EM> &mdash; a shape that is comprised of four blocks, kind of like how a <EM>domino</EM> is a shape made up of two blocks &mdash; combined with &ldquo;tennis&rdquo;, a favorite activity of the game&rsquo;s original creator, Alexey Pajitnov.</P>
<P>While the Tetris game in general has an interesting and complicated history dating back as early as 1984, it was the <EM>Nintendo Game&nbsp;Boy</EM> version that I have the fondest memories of. Whether it was taking turns to get the high score with my mom, dad and brother or playing under the passing streetlights in the back of our van as we drove home from a family gathering, Tetris will always be one of remembered as one of my favorite video games of all time.</P>



<STYLE>
#Tetris #Resources UL { list-style: none; padding-left: 0 }
#Tetris #Resources LI { padding-bottom: 1em }

#Tetris #Resources A::before, #Tetris #Resources A::after { content: ""; display: inline-block; text-decoration: none }
#Tetris #Resources A::before { content: "\201C"; }
#Tetris #Resources A::after { content: "\201D"; } 
</STYLE>
<SECTION id="Resources">
<H3>Additional Resources</H3>
<UL>
<LI><A HREF="https://tetris.com">The Addictive Puzzle Game that Started It All!,</A> Alexey Pajitnov and Henk Rogers, <EM>Tetris.com,</EM> <TIME DATETIME="2020-01-01">2020</TIME>.</LI>
<LI><A HREF="https://www.mobygames.com/game/gameboy/tetris_gb">Tetris for Game Boy (1989),</A> 雷堂嬢太朗 (Jotaro Raido), <CITE>Moby Games,</CITE> <TIME DATETIME="2009-12-19">2009</TIME>.</LI>
</UL>
</SECTION>
</ARTICLE>

<!-- DEBUGGER -->
<STYLE>
/* DEBUG */
#debug { position: fixed; z-index: 1; top: 0; left: 0; width: 100vw; height: 100vh; padding: 1em; background: transparent; color: var(--color, black); border: none; pointer-events: none;
font-family: "IBM Plex Mono", monospace; font-weight: 100; font-size: 8pt; background: radial-gradient(circle at 2% 10%, black, transparent 20%) }
@media (prefers-color-scheme: light) {
#debug { background: radial-gradient(circle at 2% 10%, white, transparent 30%) }
}
</STYLE>
<DIV ID="debug" STYLE="opacity: 1">&nbsp;</DIV>
<SCRIPT>
let platformIcon = 'platform' in navigator ? '' : ''
let $debug = document.querySelector("#debug");
if ($debug.style.opacity) {
	listen(window, "resize", debug)
	listen(document, "click mousemove keydown keyup scroll", debug)

	Keyboard = new Proxy({}, {
		set: (obj, prop, value) => { obj[prop] = value; debug(); return true },
		deleteProperty(obj, prop) { if (prop in obj) { delete obj[prop]; debug() } }
	})

	function debug(event) {
		$debug.innerHTML = ``
		let printLine = (line) => $debug.innerHTML += `${line}<BR/>`
		printLine(`Platform: ${platformIcon ? platformIcon + ' ' : ''}${'platform' in navigator ? navigator.platform : '?'}`)
		printLine(``)
		printLine(`Screen Size: ${'screen' in window ? window.screen.width : '?'}, ${'screen' in window ? window.screen.height : '?'}`)
		printLine(`Screen Color Depth: ${'screen' in window ? window.screen.colorDepth + '-bit' : '?'}`)
		printLine(`Screen Pixel Depth: ${'screen' in window ? window.screen.pixelDepth + '-bit' : '?'}`)
		printLine(``)
		printLine(`Window Size: ${'innerWidth' in window ? window.innerWidth : '?'}, ${'innerHeight' in window ? window.innerHeight : '?'}`)
		printLine(`Window Scroll: ${'scrollX' in window ? window.scrollX : '?'}, ${'scrollY' in window ? window.scrollY : '?'}`)
		printLine(``)
		printLine(`Mouse: ${Mouse ? 'Active' : 'Inactive'}`)
		printLine(`Mouse Client: ${event && 'clientX' in event ? event.clientX : '?'}, ${event && 'clientY' in event ? event.clientY : '?'}`)
		printLine(`Mouse Layer: ${event && 'layerX' in event ? event.layerX : '?'}, ${event && 'layerY' in event ? event.layerY : '?'}`)
		printLine(`Mouse Page: ${event && 'pageX' in event ? event.pageX : '?'}, ${event && 'pageY' in event ? event.pageY : '?'}`)
		printLine(`Mouse Screen: ${event && 'screenX' in event ? event.screenX : '?'}, ${event && 'screenY' in event ? event.screenY : '?'}`)
		printLine(``)
		printLine(`Keyboard: ${Keyboard ? 'Active' : 'Inactive'}`)
		let keys = ``
		if (Keyboard) {
			const larger = (text) => `<span style="line-height:0.67em; font-size:1.5em">${text}</span>`
			let displayMap = `⌘MetaLeft ⌘MetaRight ⌃ControlLeft ⌃ControlRight ⌥AltLeft ⌥AltRight [BracketLeft ]BracketRight \`Backquote \\Backslash /Slash .Period
         -Minus =Equal ,Comma ;Semicolon 'Quote ⎵Space ↵Enter ⌫Backspace ⌦Delete ⎋Escape →ArrowRight ←ArrowLeft ↑ArrowUp ↓ArrowDown ⇞PageUp ⇟PageDown ↖Home ↘End
			⇪CapsLock ⇧ShiftLeft ⇧ShiftRight ⇥Tab ⓪Numpad0 ①Numpad1 ②Numpad2 ③Numpad3 ④Numpad4 ⑤Numpad5 ⑥Numpad6 ⑦Numpad7 ⑧Numpad8 ⑨Numpad9 ⊜NumpadEqual 
         ⨸NumpadDivide ⊗NumpadMultiply ⊝NumpadSubtract ⊕NumpadAdd ⏎NumpadEnter`
			keys = Object.keys(Keyboard).map(key => {
				let display = key.replace(/Digit|Key/g, '')
				if (displayMap.indexOf(key) > -1) display = displayMap[displayMap.indexOf(key) - 1]
				return display
				//switch (key) {
				//case "Tab": return larger(Keyboard.ShiftLeft || Keyboard.ShiftRight ? '\u21E4' : '\u21E5')
				//default: return key.replace(/Digit|Key/g,'') }
			})
			printLine(`Keyboard: ${keys.length ? keys.join('') : ''}`)
		} else printLine(`Keyboard: `)
	}
	debug()
}
</SCRIPT>